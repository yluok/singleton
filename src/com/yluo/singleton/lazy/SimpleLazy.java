package com.yluo.singleton.lazy;

/**
 * 懒汉式单例实现方式之一：简单方式
 * 优点：相对于饿汉式，其实例对象，只在使用的时候才创建，解决了饿汉式占用内存不拉屎的缺点
 * 缺点：存在线程安全问题
 * 具体原因：当多线程运行时，当某个线程进入到getInstance(),并成功满足了if判断；此时另外一个线程成功抢占了cpu执行权，
 *           由于此时该实例对象并没有创建出来，所以该线程也能成功满足if条件，这样两个线程都可以创建出各自的对象出来；
 *           这样就不再是多线程单例了
 * 该方式只有在：某个线程成功创建出实例对象，在此过程中，其余线程并没有获取到cpu执行权，进入到getInstance()方法中，此时才是真正单例的。
 * 备注：即使通过打印地址发现两个对象地址相同，也不代表该过程中对象只被创建了一次，仍存在对象被创建两次，最后打印时，后创建出来的对象
 * 覆盖掉前面创建对象，造成结果单例的假象。
 *
 */
public class SimpleLazy {
    //1、私有化其构造方法
    private SimpleLazy(){}

    //2、创建一个静态变量，用于指向返回的实例对象，
    //备注：关于此处为什么该变量是static:因为获取实例对象的入口方法是静态的，如果静态方法无法使用非静态的成员变量
    private static SimpleLazy simpleLazy;

    //3、对外提供一个获取该实例对象的入口
    //备注：关于此处为什么入口方法是静态的：因为构造方法已被私有化，如果入口方法不静态，那么就没有办法访问到该方法
    // （备注：常规方式，如果仍然想调用到该方法，只有反射一条路，不符合常规思维）
    public static SimpleLazy getInstance() {
        //3.1 先判断变量是否已经被赋值，如果赋值，就直接返回
        if(simpleLazy == null) {            //此处是线程风险
            simpleLazy = new SimpleLazy();
        }
        return simpleLazy;
    }

}
